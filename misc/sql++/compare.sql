-- let $data := 
-- [
--     {key: "A", value: 10},
--     {key: "B", value: 20},
--     {key: "A", value: 30}
-- ]

-- Code in SQL++ (AsterixDB)

-- create type/schema of table
create type KVPair as {
    id: uuid,
    k: string,
    v: int
};

-- create dataset
create dataset ToyData(KVPair) primary key id autogenerated;

-- insert data
insert into ToyData(
    [
        {"k": "A", "v": 10},
        {"k": "B", "v": 20},
        {"k": "A", "v": 30}
    ]
);

-- since we have used an open schema, we can also insert data having additional fields
insert into ToyData(
    [
        {"k": "A", "v": 10, "x": 100},
        {"k": "B", "v": 20, "x": 200},
        {"k": "A", "v": 30, "x": 300}
    ]
);

-- to see the data
select value {"k": k, "v": v} from ToyData;



-- (: -----------------------------------------Simple----------------------------------------- :)
-- raw values
select value v from ToyData;

-- sum
select value sum(v) from ToyData;

-----------------------------------------Group-by-----------------------------------------
-- (: example 1 :)
-- let query = {
--   total: api.sum("data.*.value"),
--   "data.*.key": api.sum("data.*.value"),
-- }

-- from my initial exploration, it seems like they don't have a way to merge JSON objects so the result is not in the exact form required

-- let $q_exp_1_1 := {|
--     for $item in $data[]
--     group by $key := $item.key
--     return {
--         $key: sum($item.value)
--     },
--     {"total": sum($data[].value)}
--     |}

select value {
    "total": (select value sum(v) from ToyData)[0],
    "data": (
        select value { k: sum(v)} from ToyData group by k )
    };

-- object_merge(json1, json2) only takes two jsons, but if we had a variant that takes a list of jsons, we could get the desired result


-- (: example 2: group-by + average :)
-- (:
-- let query = {
--   total: api.sum("data.*.value"),
--   "data.*.key": avg("data.*.value"),
-- }
-- :)

select value {
    "total": (select value sum(v) from ToyData)[0],
    "data": (
        select value { k: avg(v)} from ToyData group by k
        )
};

-- (: example 3: group-by Relative Sum :)
-- (: 
-- let query = {
--   total: api.sum("data.*.value"),
--   "data.*.key": api.fdiv(api.sum("data.*.value"),api.sum("data.*B.value"))
-- }
--  :)

-- From the optimized logical plan it seems they are hoisting the nested aggregate
select value {
    t1.k: (sum(t1.v) / (select value sum(t2.v) from ToyData t2)[0])
    }
from ToyData t1 group by t1.k;


-- (: Example 4: Nested Group and Aggregate :)

let $data2 := [
  {region: "Asia", country: "Japan", city: "Tokyo", population: 30},
  {region: "Asia", country: "China", city: "Beijing", population: 20},
  {region: "Europe", country: "France", city: "Paris", population: 10},
  {region: "Europe", country: "UK", city: "London", population: 10}
]

-- create type CountryType as {
-- id: uuid,
-- region: string,
-- country: string,
-- city: string,
-- population: int
-- };

-- create dataset CountryData(CountryType) primary key id autogenerated;

-- insert data
insert into CountryData(
    [
        {"region": "Asia", "country": "Japan", "city": "Tokyo", "population": 30},
        {"region": "Asia", "country": "China", "city": "Beijing", "population": 20},
        {"region": "Europe", "country": "France", "city": "Paris", "population": 10},
        {"region": "Europe", "country": "UK", "city": "London", "population": 10}
    ]
);

-- there's no notion of "iteration" that makes it difficult to compose queries that would operate on say, a subset of objects from a group by
select value 
{
    "total": (select value sum(t1.population) from CountryData t1)[0],
    "data": (
        select value {
            "total": sum(t2.population),
            "data": (
                select value {t3.country: t3.population} from CountryData t3 where t3.region = t2.region
                )
            }
        from CountryData t2 group by t2.region
    )
};

-- let query = {
--   total: api.sum("data.*.population"),
--   "data.*.region": {
--     total: api.sum("data.*.population"),
--     "data.*.city": api.sum("data.*.population")
--   },
-- }

--  (: Note - concise and controllable iteration via "*" :)


-- (: -----------------------------------------Join----------------------------------------- :)

(: Example 1: Join :)
let $other := [
  {region: "Asia", country: "Japan"},
  {region: "Asia", country: "China"},
  {region: "Europe", country: "France"},
  {region: "Europe", country: "UK"}
]

let $data3 := [
  {country: "Japan", city: "Tokyo", population: 30},
  {country: "China", city: "Beijing", population: 20},
  {country: "France", city: "Paris", population: 10},
  {country: "UK", city: "London", population: 10}
]



let $q_join_1 := {|
      for $left in $other[]
      group by $region := $left.region
      return {
          $region: {|                                  (: TODO - if I had used $left.region it duplicates the group by -- feature or bug? :)
              for $right in $data3[]
              where $left.country = $right.country
              return {
                  $right.city: $right.population 
              }
              |}
      }
    |}


(: Example 2: Join with aggregate :)

(:
let query = {
  total: api.sum("data.*.population"),
  "-": api.merge(api.get(q1,"data.*.country"), {
    total: api.sum("data.*.population"),
    "data.*.city": api.sum("data.*.population")
  }),
}
:)

let $q_join_2 := {|
      {"total": sum($data3[].population)},
      for $region_item in $other[], $country_item in $data3[]
      where $region_item.country = $country_item.country
      group by $region := $region_item.region
      return {
          $region:
              {|
                {"total": sum($country_item.population)},
                for $city in $country_item
                return {
                    $city.city: $city.population
                }
              |}
      }
    |}

(: change this to the query you want to run :)
return $q_join_2 
