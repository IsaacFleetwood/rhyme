% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}

\pagestyle{plain}
\usepackage{lineno}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{subcaption}
\usepackage{multicol}

\input{macros.tex}

\linenumbers 

\newcommand{\lang}{\textcolor{blue}{QL-TBD}}

\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
%\usepackage{color}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%
\begin{document}
%
\title{Building a Query Language?}

%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
% \author{Supun Abeysinghe\inst{1}\orcidID{0000-1111-2222-3333} \and
% Tiark Rompf\inst{2,3}\orcidID{1111-2222-3333-4444}}
% \author{Supun Abeysinghe \and Tiark Rompf}
% %
% \authorrunning{F. Author et al.}
% % First names are abbreviated in the running head.
% % If there are more than two authors, 'et al.' is used.
% %
% \institute{Purdue University, West Lafayette IN 47906, USA\\
% \email{\{tabeysin,tiark\}@purdue.com}
% }
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
We propose an expressive language for high-level data manipulation that
mainly targets querying nested structures (e.g., JSON) and produce nested
structures as results.
Our query language resembles existing object notation, compositional, and
permits query optimization and code generation via construction of an
intermediate representation (IR).


\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%
\section{Introduction}

Modern web applications are commonly structured in a tiered architecture, where distinct
tiers are implemented using various techniques.
First tier, the front-end, manages the visual aspects of the application.
It is typically developed using a combination of technologies, including HTML,
CSS, and JavaScript (JS).
Specifically, JS frameworks such as React and Angular are frequently employed to
facilitate this process.
The front-end component interacts with an intermediate layer, commonly referred to as
the application tier. 
This interaction occurs through mechanisms like REST endpoints or more expressive query
languages such as GraphQL, which are employed to retrieve the necessary data for
presentation to the end user.
Subsequently, the application tier issues queries to a third tier known as the database tier.
This tier executes the received queries on stored data, generating the desired output
as a result.


The majority of these tiers operate on data structured in semi-structured
formats, such as JSON.
As a result, a range of query languages has emerged, each designed to efficiently
query data in such formats.
Prominent examples include JSONiq, AQL, SQL++~\cite{sqlpp}, UNQL, JAQL, among others.
These query languages offer expressive means to interact with semi-structured data.
However, it is worth noting that their primary focus tends to be on catering to
large-scale analytics engines, akin to workloads encountered in big data environments,
with less emphasis placed on front-end logic.
In contrast, GraphQL has garnered widespread popularity as a front-end query language
for its ability to provide a straightforward and intuitive interface for querying data.
Nonetheless, results from these GraphQL queries are manipulated by front-end JavaScript,
and logic related to other aspects of the front-end needs to be separately
(i.e., outside of the query) implemented.

% The actual logic for evaluating these queries, referred to as resolvers, typically
% requires manual implementation in the backend.
% These resolver implementations are responsible for invoking queries to a database
% and handling the corresponding data retrieval and transformation tasks.

In this work, we present a novel \emph{unified} query language named \lang{}, an expressive
language capable of high-level data manipulation of nested structures like JSON while 
also having the capability to express other aspects of front-end logic like visual components
within the same query.
\lang{} has a simple and intuitive syntax that resembles existing object notation.
We design \lang{} to be compositional, having the capability to perform query optimizations
and code generation via the construction of an intermediate representation (IR).
In essence, our overarching goal with \lang{} is to allow developers to build interactive dashboards and 
CRUD applications directly from a single query, that essentially becomes the `program'.
\lang{} takes inspiration from existing approaches like Graph QL, JQ, XQuery, etc., einstein
notation (Einsum, Einops) in tensor frameworks, and logic programming (Datalog).

% TODO: maybe highlight the fact that this compositionality, mixing of visual aspects, etc.
%       is enabled by the fact that our query language resembles JSON so that we can directly
%       process that in JS

Our specific contributions are as follows.

\begin{enumerate}
    \item We present the syntax of our query language and demonstrate how to express common
          data manipulation operators like, selections, group-bys, joins, user-defined functions (UDFs),
          and so on.
          Moreover, we show how to express visual components, and how to compose them to build
          large queries (\Cref{sec:query_language}).
    \item We show how the queries are lowered into an IR that contains loop-free and branch-free code
          with dependencies implicitly representing the program structure.
          Then, we demonstrate how this IR can be used to generate code for a given query by constructing
          the program structure from dependencies.
          Moreover, we show how traditional compiler optimizations like lambda lifting translates to query
          optimizations like sub-query de-correlation (\Cref{sec:ir_codegen}).
    \item We demonstrate the capabilities of our overall query language by taking a relatively simple example
          program that uses most of the features we have presented in previous sections (\Cref{sec:case_study}).
    \item We compare the performance of \lang{} on several practical JSON analytics workloads to demonstrate the
          effectiveness of our code generation approach (\Cref{sec:experiments}).
\end{enumerate}

We discuss related work in \Cref{sec:related_work}, followed by conclusions and potential future research directions
in \Cref{sec:conclusions}.


\section{The Query Language}~\label{sec:query_language}

In this section, we will introduce the syntax of the \lang{}, illustrating how it facilitates
the expression of common data manipulation operations like selections, aggregates,
group-bys, and so on.
To enhance comprehension, we will employ a running illustrative example dataset, as
depicted below.
Specifically, we have a dataset of containing population of several major cities,
along with the respective country.
Our chosen dataset is deliberately kept relatively straightforward, devoid of
intricate nested structures.
However, it is worth noting that \lang{} has the capacity to seamlessly query
deeply nested JSON data without any problem in the same way.


\begin{lstlisting}[style=JavaScript]
let data = [
    {country: "Japan", city: "Tokyo",     population: 14},
    {country: "China", city: "Beijing",   population: 22},
    {country: "France",city: "Paris",     population: 3},
    {country: "UK",    city: "London",    population: 9},
    {country: "Japan", city: "Osaka",     population: 3},
    {country: "UK",    city: "Birmingham",population: 2}
]
\end{lstlisting}

% \begin{lstlisting}[style=JavaScript]
% let data = [
%     {key: "A", val: 20},
%     {key: "B", val: 30},
%     {key: "A", val: 10}
% ]
% \end{lstlisting}

\subsection{Basics}
First we will look at how to perform several basic query operations on the
aforementioned dataset.
For instance, if we want to select a particular key of the dataset at a given
index, we can use the following syntax.

\begin{lstlisting}[style=JavaScript]
data.0.country              // result: Japan
{first : data.0.country}    // result: {first: Japan}
\end{lstlisting}

Several key attributes of \lang{} can be observed from the aforementioned examples.
In the given illustration, the reference \inline{data} refers to
the dataset object, enabling simple indexing into the array of data through integer
indices.
Furthermore, the selection of specific keys is facilitated by specifying the desired
key names (e.g., \inline{.country}).
Notably, \lang{} offers the convenience of the familiar JS-like syntax for constructing
structured output from extracted values, as exemplified in the second instance.

While this form of explicit indexing into the array can be useful for several
use cases, generally, queries involve some form of iterating over the dataset.
\lang{} offers this capability through the \inline{*} operator,
serving as an implicit iteration operator.
Later in our discussion, we will delve into how this operator empowers fine-grained
iterations, utilizing multiple iterators
(e.g., \inline{*A}, \inline{*B}, etc.).
For now, our focus centers on relatively simple queries.
Below, we present several example queries that leverage iteration and compute
aggregates over the iterated values.

\begin{lstlisting}[style=JavaScript, columns=flexible]
[data.*.city]             // result: [Tokyo, Beijing, ..., Birmingham]
sum(data.*.population)    // result: 53
max(data.*.population)    // result: 22
\end{lstlisting}

The queries presented above are self-explanatory in nature.
In the first example, we illustrate a scenario where an array can be constructed
from the values obtained through iteration, employing the \inline{[...]} syntax.
Alternatively, users can compute aggregates over the iterated values using the
relevant aggregate functions, such as \inline{sum}, \inline{max}, and so forth.
As discussed previously, this queries can be used as parts of object
construction logic and combined flexibly as shown below.

\begin{minipage}{0.5\textwidth}
\begin{lstlisting}[style=JavaScript, columns=flexible, numbers=none]
{
    total: sum(data.*.population),
    max: max(data.*.population)
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{0.5\textwidth}
\begin{lstlisting}[style=JSComment, columns=flexible, numbers=none]
result: 
{
    total: 53,
    max: 22
}
\end{lstlisting}
\end{minipage}


\subsection{Group By}
\subsection{Filters}
\subsection{Join}
\begin{lstlisting}[style=JavaScript]
let other = [
    {country: "Japan", region: "Asia"},
    {country: "China", region: "Asia"},
    {country: "France",region: "Europe"},
    {country: "UK",    city: "Europe"},
]
\end{lstlisting}
\subsection{Used-defined Functions}
\subsection{Arrays}
\subsection{Fluent API}

\subsection{GUI Components}
Basic building blocks -- table definition, and generic display, svg, etc. 

\section{IR and Code Generation}~\label{sec:ir_codegen}
\subsection{IR Structure}
Loop-free and branch-free code, program structure implicit in dependencies

\subsection{Code Generation}
Scheduling based on dependencies, lambda lifting to de-correlate queries

\subsection{Implementation}
We implement this in JavaScript so that it can run in the browser.


\section{Example: Pivot Table}\label{sec:case_study}
How to use group bys, partial aggregates, display, svg, etc.

\section{Experiments}\label{sec:experiments}


\section{Related Work}\label{sec:related_work}

\section{Conclusions and Future Work}\label{sec:conclusions}
Incrementality, Datalog-style recursive queries?, partial re-evaluation as
query changes (with minimal recomputation and index sharing)
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.

\bibliographystyle{splncs04}
\bibliography{references}
\end{document}
