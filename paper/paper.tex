% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}

\pagestyle{plain}
\usepackage{lineno}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{listings}

\input{macros.tex}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

\linenumbers 

\newcommand{\lang}{\textcolor{blue}{QL-TBD}}

\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
%\usepackage{color}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%
\begin{document}
%
\title{Building a Query Language?}

%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
% \author{Supun Abeysinghe\inst{1}\orcidID{0000-1111-2222-3333} \and
% Tiark Rompf\inst{2,3}\orcidID{1111-2222-3333-4444}}
% \author{Supun Abeysinghe \and Tiark Rompf}
% %
% \authorrunning{F. Author et al.}
% % First names are abbreviated in the running head.
% % If there are more than two authors, 'et al.' is used.
% %
% \institute{Purdue University, West Lafayette IN 47906, USA\\
% \email{\{tabeysin,tiark\}@purdue.com}
% }
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
We propose an expressive language for high-level data manipulation that
mainly targets querying nested structures (e.g., JSON) and produce nested
structures as results.
Our query language resembles existing object notation, compositional, and
permits query optimization and code generation via construction of an
intermediate representation (IR).


\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%
\section{Introduction}

Modern web applications are commonly structured in a tiered architecture, where distinct
tiers are implemented using various techniques.
First tier, the front-end, manages the visual aspects of the application.
It is typically developed using a combination of technologies, including HTML,
CSS, and JavaScript.
Specifically, JavaScript frameworks such as React and Angular are frequently employed to
facilitate this process.
The front-end component interacts with an intermediate layer, commonly referred to as
the application tier. 
This interaction occurs through mechanisms like REST endpoints or more expressive query
languages such as GraphQL, which are employed to retrieve the necessary data for
presentation to the end user.
Subsequently, the application tier issues queries to a third tier known as the database tier.
This tier executes the received queries on stored data, generating the desired output
as a result.


The majority of these tiers operate on data structured in semi-structured
formats, such as JSON.
As a result, a range of query languages has emerged, each designed to efficiently
query data in such formats.
Prominent examples include JSONiq, AQL, SQL++~\cite{sqlpp}, UNQL, JAQL, among others.
These query languages offer expressive means to interact with semi-structured data.
However, it is worth noting that their primary focus tends to be on catering to
large-scale analytics engines, akin to workloads encountered in big data environments,
with less emphasis placed on front-end logic.
In contrast, GraphQL has garnered widespread popularity as a front-end query language
for its ability to provide a straightforward and intuitive interface for querying data.
Nonetheless, results from these GraphQL queries are manipulated by front-end JavaScript,
and logic related to other aspects of the front-end needs to be separately
(i.e., outside of the query) implemented.

% The actual logic for evaluating these queries, referred to as resolvers, typically
% requires manual implementation in the backend.
% These resolver implementations are responsible for invoking queries to a database
% and handling the corresponding data retrieval and transformation tasks.

In this work, we present a novel \emph{unified} query language named \lang{}, an expressive
language capable of high-level data manipulation of nested structures like JSON while 
also having the capability to express other aspects of front-end logic like visual components
within the same query.
\lang{} has a simple and intuitive syntax that resembles existing object notation.
We design \lang{} to be compositional, having the capability to perform query optimizations
and code generation via the construction of an intermediate representation (IR).
In essence, our overarching goal with \lang{} is to allow developers to build interactive dashboards and 
CRUD applications directly from a single query, that essentially becomes the `program'.
\lang{} takes inspiration from existing approaches like Graph QL, JQ, XQuery, etc., einstein
notation (Einsum, Einops) in tensor frameworks, and logic programming (Datalog).

% TODO: maybe highlight the fact that this compositionality, mixing of visual aspects, etc.
%       is enabled by the fact that our query language resembles JSON so that we can directly
%       process that in JS

Our specific contributions are as follows.

\begin{enumerate}
    \item We present the syntax of our query language and demonstrate how to express common
          data manipulation operators like, selections, group-bys, joins, user-defined functions (UDFs),
          and so on.
          Moreover, we show how to express visual components, and how to compose them to build
          large queries (\Cref{sec:query_language}).
    \item We show how the queries are lowered into an IR that contains loop-free and branch-free code
          with dependencies implicitly representing the program structure.
          Then, we demonstrate how this IR can be used to generate code for a given query by constructing
          the program structure from dependencies.
          Moreover, we show how traditional compiler optimizations like lambda lifting translates to query
          optimizations like sub-query de-correlation (\Cref{sec:ir_codegen}).
    \item We demonstrate the capabilities of our overall query language by taking a relatively simple example
          program that uses most of the features we have presented in previous sections (\Cref{sec:case_study}).
    \item We compare the performance of \lang{} on several practical JSON analytics workloads to demonstrate the
          effectiveness of our code generation approach (\Cref{sec:experiments}).
\end{enumerate}

We discuss related work in \Cref{sec:related_work}, followed by conclusions and potential future research directions
in \Cref{sec:conclusions}.


\section{The Query Language}~\label{sec:query_language}
\begin{lstlisting}[style=JavaScript]
let data = [
    {country: "Japan",  city: "Tokyo",   population: 30},
    {country: "China",  city: "Beijing", population: 20},
    {country: "France", city: "Paris",   population: 10},
    {country: "UK",     city: "London",  population: 10},
]
\end{lstlisting}

\begin{lstlisting}[style=JavaScript]
sum("data.*.population")
max("data.*.population")
avg("data.*.population")

\end{lstlisting}
\subsection{Basics}
aggregation, etc.

\subsection{Group By}
\subsection{Filters}
\subsection{Join}
\subsection{Used-defined Functions}
\subsection{Arrays}
\subsection{Fluent API}

\subsection{GUI Components}
Basic building blocks -- table definition, and generic display, svg, etc. 

\section{IR and Code Generation}~\label{sec:ir_codegen}
\subsection{IR Structure}
Loop-free and branch-free code, program structure implicit in dependencies

\subsection{Code Generation}
Scheduling based on dependencies, lambda lifting to de-correlate queries

\subsection{Implementation}
We implement this in JavaScript so that it can run in the browser.


\section{Example: Pivot Table}\label{sec:case_study}
How to use group bys, partial aggregates, display, svg, etc.

\section{Experiments}\label{sec:experiments}


\section{Related Work}\label{sec:related_work}

\section{Conclusions and Future Work}\label{sec:conclusions}
Incrementality, Datalog-style recursive queries?, partial re-evaluation as
query changes (with minimal recomputation)
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.

\bibliographystyle{splncs04}
\bibliography{references}
\end{document}
